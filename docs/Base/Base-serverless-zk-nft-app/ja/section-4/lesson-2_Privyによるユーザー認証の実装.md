---
title: "Privyによるユーザー認証の実装"
---

このレッスンでは、Privyを導入して、ユーザーがEメールやソーシャルアカウントで簡単にログインできるようにし、各ユーザーに専用のウォレット（Embedded Wallet）を自動的に提供する機能を実装します。これにより、web3に慣れていないユーザーでもシームレスにアプリを利用できるようになります。

## 🔑 Privyとは？

Privyは、web3アプリケーションのオンボーディングを劇的に簡単にするためのツールキットです。主な機能は以下の通りです。

- **柔軟な認証**: Eメール、SMS、Google、Twitterなどのソーシャルログインを提供します。
- **Embedded Wallets**: ユーザーがログインすると、バックグラウンドで自動的にウォレットが作成・管理されます。ユーザーは秘密鍵やシードフレーズを意識する必要がありません。
- **外部ウォレット連携**: MetaMaskやPhantomなどの既存のウォレットを接続することもサポートしています。

このプロジェクトでは、Privyを使ってユーザー認証とウォレット管理をシンプルに実装します。

## 🛠 Privyのセットアップ

まず、必要なPrivyのパッケージをインストールします。

```bash
cd pkgs/frontend
pnpm install @privy-io/react-auth @privy-io/export-wallets
```

次に、Privyの管理画面でアプリケーションを登録し、App IDを取得する必要があります。

1.  [Privyの公式サイト](https://www.privy.io/)にアクセスし、サインアップまたはログインします。
2.  ダッシュボードで新しいアプリケーションを作成します。
3.  作成したアプリケーションのページで、`App ID`をコピーします。

取得した`App ID`を、`pkgs/frontend`ディレクトリに`.env.local`というファイルを作成して保存します。

```
NEXT_PUBLIC_PRIVY_APP_ID=YOUR_PRIVY_APP_ID
```
※ `YOUR_PRIVY_APP_ID`は実際に取得したIDに置き換えてください。

## 🔌 PrivyProviderの組み込み

Privyをアプリケーション全体で利用できるように、`PrivyProvider`でラップします。クライアントサイドでのみ動作するため、専用のプロバイダーコンポーネントを作成します。

`pkgs/frontend/src/app/providers.tsx`というファイルを作成し、以下のコードを記述します。

```tsx
// pkgs/frontend/src/app/providers.tsx
"use client";

import { PrivyProvider } from "@privy-io/react-auth";

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <PrivyProvider
      appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID!}
      config={{
        // 表示するログイン方法を設定
        loginMethods: ["email", "wallet"],
        // 表示するウォレットを設定
        embeddedWallets: {
          createOnLogin: "users-without-wallets", // ウォレットを持っていないユーザーには自動で作成
        },
      }}
    >
      {children}
    </PrivyProvider>
  );
}
```

### コード解説
- `PrivyProvider`: このコンポーネントでアプリケーション全体をラップすることで、どのコンポーネントからでも`usePrivy`フックを使って認証情報にアクセスできるようになります。
- `appId`: 環境変数から先ほど設定したApp IDを読み込みます。
- `config`: ログインモーダルの設定です。ここではEメールと外部ウォレットでのログインを許可し、ウォレットを持っていないユーザーには自動でEmbedded Walletを作成するように設定しています。

## 🌐 アプリケーションへの適用

作成した`Providers`をアプリケーションのルートレイアウトに適用します。`pkgs/frontend/src/app/layout.tsx`を以下のように修正してください。

```tsx
// pkgs/frontend/src/app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers"; // 👈 インポート

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Providers> {/* 👈 ここでラップ */}
          {children}
          <Toaster />
        </Providers> {/* 👈 ここでラップ */}
      </body>
    </html>
  );
}
```

## 👤 ログイン/ログアウトボタンの追加

`page.tsx`を更新して、Privyの`usePrivy`フックを使い、ユーザーの認証状態に応じてUIを変化させ、ログイン・ログアウト機能を実装します。

`pkgs/frontend/src/app/page.tsx`を以下のように更新します。

```tsx
//
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { usePrivy } from "@privy-io/react-auth"; // 👈 usePrivyフックをインポート
import { useState } from "react";

export default function Home() {
  const [password, setPassword] = useState<string>("");
  // usePrivyフックから認証情報を取得
  const { ready, authenticated, user, login, logout } = usePrivy();

  // Privyが初期化されるまでローディング表示
  if (!ready) {
    return <p>Loading...</p>;
  }

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <div className="z-10 w-full max-w-5xl items-center justify-between font-mono text-sm lg:flex">
        <p className="fixed left-0 top-0 flex w-full justify-center border-b border-gray-300 bg-gradient-to-b from-zinc-200 pb-6 pt-8 backdrop-blur-2xl dark:border-neutral-800 dark:bg-zinc-800/30 dark:from-inherit lg:static lg:w-auto  lg:rounded-xl lg:border lg:bg-gray-200 lg:p-4 lg:dark:bg-zinc-800/30">
          Welcome to UNCHAIN ZK NFT App
        </p>
        {/* 認証状態でボタンを切り替え */}
        {authenticated ? (
          <Button onClick={logout}>Logout</Button>
        ) : (
          <Button onClick={login}>Login</Button>
        )}
      </div>

      <div className="relative z-[-1] flex place-items-center">
        <h1 className="text-5xl font-bold text-center">
          Serverless ZK NFT App
        </h1>
      </div>

      {/* 認証済みの場合のみミントUIを表示 */}
      {authenticated && user?.wallet && (
        <>
          <p className="mt-4">
            Your wallet address: {user.wallet.address}
          </p>
          <div className="mb-32 mt-8 grid text-center lg:mb-0 lg:w-full lg:max-w-5xl lg:grid-cols-4 lg:text-left">
            <div className="group rounded-lg border border-transparent px-5 py-4 transition-colors hover:border-gray-300 hover:bg-gray-100 hover:dark:border-neutral-700 hover:dark:bg-neutral-800/30">
              <h2 className="mb-3 text-2xl font-semibold">
                Mint ZK NFT
              </h2>
              <div className="flex w-full max-w-sm items-center space-x-2">
                <Input
                  type="password"
                  placeholder="Password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                />
                <Button type="submit">Mint</Button>
              </div>
            </div>
          </div>
        </>
      )}
    </main>
  );
}
```

### コード解説
- `usePrivy()`: Privyのフックを呼び出し、認証状態(`ready`, `authenticated`)、ユーザー情報(`user`)、そしてログイン・ログアウト関数(`login`, `logout`)を取得します。
- `if (!ready)`: Privyが初期化されるまではローディング画面を表示し、エラーを防ぎます。
- `authenticated ? <Button onClick={logout}>Logout</Button> : <Button onClick={login}>Login</Button>`: ユーザーが認証済みかどうかで、表示するボタンを「Logout」と「Login」で切り替えます。
- `{authenticated && user?.wallet && ...}`: ユーザーが認証済みで、かつウォレット情報が存在する場合にのみ、ウォレットアドレスとNFTのミント用UIを表示します。

これで、アプリケーションに基本的な認証フローが実装できました。アプリケーションを起動して、右上の「Login」ボタンから実際にログインできることを確認してみてください。

---

次のレッスンでは、いよいよこのプロジェクトの核心である「クライアントサイドでのZK証明生成」を実装していきます。

### 🙋‍♂️ 質問する

ここまでの作業で何かわからないことがある場合は、Discordの`#zk`で質問をしてください。

ヘルプをするときのフローが円滑になるので、エラーレポートには下記の3点を記載してください ✨

1. 質問が関連しているセクション番号とレッスン番号
2. 何をしようとしていたか
3. エラー文をコピー&ペースト
4. エラー画面のスクリーンショット
